
## Tabela 1: Algoritmos e Estrutura de Dados

| **Tópicos Principais** | **Subtópicos** | **Detalhes** |
|------------------------|----------------|--------------|
| 1. Estruturas Lineares | 1.1 Listas     | Listas encadeadas, listas duplamente encadeadas, listas circulares |
|                        | 1.2 Pilhas     | Implementação com arrays e listas, aplicações, complexidade |
|                        | 1.3 Filas      | Filas simples, filas circulares, filas de prioridade |
| 2. Dicionários         | 2.1 Hashmaps   | Tabelas de dispersão, funções de hash, tratamento de colisões |
| 3. Análise de Complexidade | 3.1 Notações assintóticas | O, Ω, Θ; análise de algoritmos recursivos |
| 4. Heaps               | 4.1 Heap Máximo e Mínimo | Inserção, remoção, heapify, aplicação em filas de prioridade |
| 5. Árvores             | 5.1 Árvores Binárias | Travessias (pré, in, pós), altura, balanceamento |
|                        | 5.2 Árvores de Busca Binária (BST) | Inserção, remoção, busca |
| 6. Union-Find          | 6.1 Estrutura Disjoint Set | União por rank, compressão de caminho |
| 7. Grafos              | 7.1 Conceitos básicos | Representação (matriz de adjacência, lista de adjacência) |
|                        | 7.2 Busca em largura (BFS) | Aplicações em caminhos mínimos em grafos não ponderados |
|                        | 7.3 Busca em profundidade (DFS) | Ciclos, componentes conexas |
|                        | 7.4 Grafos ponderados | Algoritmo de Dijkstra |
| 8. Árvores Geradoras Mínimas | 8.1 Algoritmo de Prim | Implementação com heap |
|                              | 8.2 Algoritmo de Kruskal | Union-Find aplicado |
| 9. Programação Dinâmica | 9.1 Problemas clássicos | Mochila, subsequência comum mais longa, cortes de hastes |
|                         | 9.2 Estratégias | Recursão com memoização, bottom-up |

---

## Tabela 2: System Design

| **Tópicos Principais** | **Subtópicos** | **Detalhes** |
|------------------------|----------------|--------------|
| 1. Fundamentos de Sistemas Distribuídos | 1.1 Conceitos básicos | O que são sistemas distribuídos, motivação e cenários de uso |
|                                       | 1.2 Benefícios        | Escalabilidade, tolerância a falhas, disponibilidade |
|                                       | 1.3 Desafios          | Consistência, latência, particionamento, coordenação |
| 2. Entrevistas de System Design       | 2.1 Estratégias de resolução | Como abordar problemas abertos em entrevistas técnicas |
|                                       | 2.2 Estrutura da resposta | Levantamento de requisitos, trade-offs, desenho de alto nível |
|                                       | 2.3 Exemplos de perguntas comuns | Design de URL shortener, sistema de mensagens, feed de redes sociais |
| 3. Componentes de Arquiteturas Distribuídas | 3.1 Load balancers | Conceito, tipos (L4 vs L7), uso em distribuição de carga |
|                                            | 3.2 Caches           | Cache local, cache distribuído, políticas LRU, TTL |
|                                            | 3.3 Comunicação via APIs | REST, gRPC, boas práticas de design de API |
|                                            | 3.4 Armazenamento e bancos de dados | SQL vs NoSQL, particionamento, replicação |
| 4. Fundamentos de DevOps              | 4.1 Integração contínua e entrega contínua (CI/CD) | Ferramentas e práticas modernas de automação de deploy |
|                                       | 4.2 Monitoramento e observabilidade | Logs, métricas, alertas |
|                                       | 4.3 Infraestrutura como código | Containers (Docker), orquestração (Kubernetes), provisionamento |
| 5. Avaliação e Feedback               | 5.1 Rubrica de avaliação | Critérios usados para avaliar a solução de um projeto de System Design |
|                                       | 5.2 Autoavaliação orientada | Reflexão sobre decisões tomadas e trade-offs feitos |
